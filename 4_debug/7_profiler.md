# Профайлдах

Ачааллын тестийн дүнд програм ачаалал даах чадваргүй нь тогтоогдож болно. Ийм програмын хувьд цааш нь илүү нарийн шинжилгээ хийх шаардлагатай болдог. Ө.х програмд илүү нарийн шинжилгээ хийж ямар функц, ямар кодын мөр дээр илүү их хугацаа эсвэл санах ой зарцуулаад байгааг харах хэрэгтэй болно.

Програмын динамик шинж буюу ажиллаж байх үеийн шинж чанарыг нарийвчлан шинжлэх үйлдлийг профайлдах гэж хэлдэг.

“Хэмжиж чадахгүй бол сайжруулж чадахгүй” гэж нэг үг байдаг. Үнэхээр хэмжилтийн чухал багажуудыг мэдэхгүй, эзэмшихгүйгээр сайн програм зохиох, сайн програм зохиогч байх боломжгүй юм.

Програм профайлдахад зориулсан хэд хэдэн багаж Go хэлэнд бий. CPU хугацаа хянах, санах ойн зарцуулалт хянах, блок илрүүлэх, GC хугацаа хянах, go функц тоолох гэх мэт төрөл бүрийн зориулалттай профайлерууд бий. Эдгээр багаж нь програмын халуун цэгийг олж тогтооход чухал үүрэгтэй байдаг.

Эдгээрээс хамгийн өргөн хэрэглэгддэг CPU болон санах ойн профайлеруудын тухай үзэе.

## CPU профайлер

CPU профайлер нь ямар функц ямар хэмжээгээр CPU нөөц зарцуулж байгааг харуулдаг.

CPU профайлерыг хэрэглэх олон арга бий. Эхний арга нь өмнө бичсэн ачааллын тест дээр үндэслэн профайлдах юм.

`go test` командыг ажиллуулахдаа `-cpuprofile` тохиргоог нэмэх хэрэгтэй.

```sh
$ go test -run=none -bench=BenchmarkHello -cpuprofile=cprof math
```

Энэ команд нь `math` пакет дахь `BenchmarkHello` тестийг ажиллуулж үр дүнг `cprof` файлд хадгална. Үүний дараа `go tool pprof` командаар үр дүнг харж болно.

```sh
$ go tool pprof --text math.test cprof
```

Үр дүнг текст, вэб, жагсаалт хэлбэрээр харж болно. Эдгээрт харгалзах `–text`, `--web`, `--list` тохиргоонууд бий.

Дараагийн арга нь pprof пакетыг профайлдах програм дотроо импортлох юм.

```go
import _ "net/http/pprof"
```
Ингээд програмаа ердийн байдлаар ажиллуулна. Үр дүнг харахын тулд вэб сервер хэрэгтэй болно. Хэрэв вэб програм бол нэмэлт вэб сервер шаардлагагүй. Шууд вэб програмын хаягаа (жнь: http://localhost:6060) `go tool pprof` багажид заагаад араас нь /debug/pprof/profile гэж дуудах хэрэгтэй. Эсвэл вэб браузер дээр энэ хаягаар орж харж болно (хурдан ажиллаад өнгөрөх програмын хувьд олж харж амжихгүй).

```sh
$ go tool pprof http://localhost:6060/debug/pprof/profile
```

Хэрэв вэб програм биш бол дотор нь вэб сервер асаах хэрэгтэй.

```go
import _ "net/http/pprof"
import "net/http"
...
func main() {
  // профайлдахад зориулж хялбар вэб сервер асаах
  go func() {
        println(http.ListenAndServe("localhost:6060", nil))
  }()
  // ... бусад код
}
```

TODO: Профайлдах үеийн зураг оруулах

## Санах ойн профайлер

Санах ойн профайлер нь ямар функц ямар хэмжээтэй санах ой ашиглаж байгааг харуулна.

CPU профайлертай төстэй `go test -memprofile` ажиллуулах, эсвэл хоёр дахь аргаар /debug/pprof/heap хаягыг дуудах замаар санах ой ашиглалтыг харж болно.

```sh
$ go test -run=none -bench=BenchmarkHello -memprofile=mprof math
```

Санах ойн яг одоогийн ашиглалтыг харах (`--inuse_space` флаг), эсвэл програм эхэлсэн цагаас хойших ашиглалтыг харах (`--alloc_space` флаг) сонголт бий. Эхнийх нь удаан ажиллах програмд тохиромжтой, дараагийнх нь хурдан дуусдаг буюу програмын төгсгөлд профайл харах үед хэрэгтэй.

Санах ойн профайлер нь жинхэнэ бодит зарцуулалтыг харуулахгүй болохыг анхаараарай. Зарим санах ойн хэсгийг жишээ болгон сонгож хэмжээд уг хэмжээнээс харьцангуй тооцож санах ойн зарцуулалтыг харуулдаг. Гэхдээ энэ үр дүн нь бодит хэмжээтэй пропорционал хамааралтай юм. Харьцааг өөрчлөх бол `--memprofilerate` флагийг ашиглах эсвэл `runtime.MemProfileRate` хувьсагчид заах боломжтой. Хэрэв энэ харьцааг `1` гэж заавал бүх санах ойн зарцуулалтыг бодит хэмжээгээр авахыг оролдоно, гэхдээ энэ нь програмын ажиллагааг ихээхэн удаашруулах болно.

Санах ойн зарцуулалтын хэмжээнээс гадна үүссэн обектын тоо, үүссэн байтын тоог харах боломжтой (`--inuse/alloc_space`, `--inuse/alloc_objects` флагууд). Санах ойн профайлер нь аль болох том хэмжээтэй обектуудыг жишээ болгон сонгодог. Гэхдээ том обект санах ой болон `GC` (Garbage Collection) хугацаанд нөлөөлдөг бол бага хэмжээтэй олон обект хурданд илүү сөрөг нөлөөтэй байдаг (мөн тодорхой хэмжээгээр `GC` хугацаанд нөлөөлнө). Тиймээс бага, том  хоёуланд нь анхаарлаа хандуулах хэрэгтэй байдаг.

Том обектыг програмын эхэнд үүсгэж ашиглавал програмын хурдад онцын нөлөө үзүүлэхгүй боловч санах ойн профайлерт хамгийн эхэнд өртөнө (том хэмжээтэй учраас). Нөгөө талаас богино хугацаатай олон тооны обект үүсгэвэл профайлерт өртөх нь бага (`--inuse/alloc_objects` ашиглаагүй бол) боловч програмын хурдад илүү нөлөөлнө. Учир нь олон удаа санах ой хувиарлах, чөлөөлөх үйлдэл хийгдэнэ гэсэн үг.

Ерөнхийдөө санах ой хэмнэхэд анхаарч байгаа бол `alloc_space` флаг, програмын хурданд анхаарч байгаа бол `alloc_objects` флагийг ашиглах хэрэгтэй.
