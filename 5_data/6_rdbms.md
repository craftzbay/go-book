#  SQL ба RDBMS

RDBMS буюу уялдаат өгөгдлийн сангийн систем нь өгөгдлийг мөр, баганаас тогтох  хүснэгт бүтцээр хадгална. RDBMS өгөгдийн сангийн гол төлөөлөгчдөөр Oracle Database, Microsoft SQL, MySQL, PostgreSQL зэргийг нэрлэж болно.

SQL хэл нь уялдаат өгөгдлийн санд байгаа өгөгдлийг удирдахад зориулсан хэл юм.  SQL командаар дамжуулан өгөгдөл оруулах, засах, устгах, унших гэх зэрэг үйлдлүүд хийх боломжтой.

SQL хэл нь стандарт болсон учраас энэ хэлийг сурвал олон SQL төрлийн баазтай ажиллах чадвартай болно.

##  SQL төрлийн өгөгдлийн сантай ажиллах

Go хэлний `database/sql` сан нь SQL төрлийн өгөгдлийн сантай ажиллах ерөнхий интерфэйс юм. Энэ сан нь ерөнхий учраас тухайлсан нэг баазтай ажиллахын тулд тухайн баазын драйвертай хослуулж ашиглах хэрэгтэй. Драйверын жагсаалтыг http://golang.org/s/sqldrivers хаягаас харж болно.

Өгөгдлийн санг `sql.DB` төрлөөр төлөөлүүлнэ. `sql.DB` обект нь өгөгдлийн сангийн холболт эсвэл тодорхой нэг бодит бааз биш, харин өгөгдлийн санг төлөөлж байгаа хийсвэр обект юм. Энэ обектоор дамжуулан SQL команд илгээх, гүйлгээ хийх, үр дүнг боловсруулах боломжтой.

`sql.DB` обектоор дамжуулан дараах үйлдлүүд хийж болно:

* бодит бааз руу холболт нээх, хаах
* холболтын олонлог үүсгэх, тэдгээрийг удирдах
* SQL команд илгээх, хариу авах

### Өгөгдлийн санд холбогдох

Өгөгдлийн сан руу холболт үүсгэхэд `sql.Open()` функцийг ашиглана. Энэ функц нь `*sql.DB` төрлийн обект буцаана:

```go
db, err := sql.Open(driver, dataSourceName)
```
sql.Open функцэд дамжуулах эхний аргумент нь драйверын нэр байна.
Хоёр дахь аргумент нь өгөгдлийн санд хэрхэн хандахыг драйверт мэдээлнэ.

Жишээлбэл локал машины MySQL сервер дээр байгаа `hello` бааз руу холболт үүсгэе.

```go
func main() {
    db, err := sql.Open("mysql",
        "user:password@tcp(127.0.0.1:3306)/hello")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
}
```

Өгөгдлийн сантай холбоотой үйлдлүүдийн араас заавал алдаа гарсан эсэхийг шалгаж байх хэрэгтэй.

Мөн өгөгдлийн сангийн холболтыг ашиглаж дуусаад хааж байх хэрэгтэй. Гэхдээ маш ойрхон давтамжтай хааж, нээх хэрэггүй. Тухайлбал програм эхлэхэд нэг `sql.DB` обект үүсгээд,  програмын ажиллагаа дуусахад түүнийг хааж болно. Харин нээх, хаах үйлдлийг давталт дотор эсвэл богино хугацаатай ажилладаг функц дотор олон дахин гүйцэтгэх нь тохиромжгүй.

Өгөгдлийн сангийн холболтыг буруу үүсгэвэл сүлжээ-нөөцийг буруу ашиглах, холболтын тоо хэтрэх, `TIME_WAIT` төлөвтэй олон холболт үүсэх гэх мэтээр асуудлууд үүснэ.

`sql.Open()` функц нь дуудагдсан дариудаа бааз руу холболт нээдэггүй, харин анхны SQL команд илгээгдэх үед холболт нээгддэг. Команд илгээхээс өмнө холболт нээх эсвэл холболт зөв эсэхийг шалгахыг хүсвэл `Ping` функцыг ашиглаж болно.

```go
err = db.Ping()
if err != nil {
    // do something here
}
```

Ингээд `sql.DB` обектыг ашиглахад бэлэн боллоо.

### Команд илгээх

Хариу өгөгдөл хэрэггүй INSERT, UPDATE, DELETE төрлийн команд илгээхэд `Exec()` функцийг ашиглана:

```go
result, err := db.Exec(
 "INSERT INTO users (name, age) VALUES (?, ?)",
 "gopher",
 27,
)
```

Энэ командын хариуд `result` обект сүүлийн INSERT үйлдлийн ID болон нийт өөрчлөгдсөн мөрийн тоог буцаана. Гэхдээ энэ утгууд нь драйвераас хамаараад ирэхгүй ч байж болно.

Өгөгдөл унших буюу асуулга хийх бол `Query` функцийг ашиглана:

```go
rows, err := db.Query("SELECT name FROM users WHERE age = ?", age)
if err != nil {
  log.Fatal(err)
}

for rows.Next() {
  var name string
  if err := rows.Scan(&name); err != nil {
  log.Fatal(err)
  }
  fmt.Printf("%s is %d\n", name, age)
}

if err := rows.Err(); err != nil {
  log.Fatal(err)
}
```

Зөвхөн нэг мөр унших бол `QueryRow()` функц тохиромжтой:

```go
var age int64
row := db.QueryRow("SELECT age FROM users WHERE name = ?", name)
err := row.Scan(&age)
```

Бэлдсэн команд үүсгэх бол `Prepare()` функцийг ашиглана:

```go
age := 27
stmt, err := db.Prepare("SELECT name FROM users WHERE age = ?")
if err != nil {
  log.Fatal(err)
}

rows, err := stmt.Query(age)
// rows дээр боловсруулалт хийх
```

Бэлдсэн команд (TODO: prepared statement-г тайлбарлах ?) дээр `Exec()`, `Query()`, `QueryRow()` функцүүдийг мөн дуудаж болно. Командыг хэрэглэж дууссаны дараа `Close()` функцээр хаах хэрэгтэй.

### Транзаагц

*Транзаагц* гэдэг нь хоёр буюу түүнээс дээш хамтдаа ажиллах SQL командыг хэлнэ.

Транзаагц доторхи бүх команд амжилттай болвол транзаагц команд бүхэлдээ амжилттай болно, эсрэгээр транзагц доторх аль нэг команд дээр алдаа гарвал бүх команд цуцлагдана.

Транзагц нь банкны гүйлгээ гүйцэтгэх зэрэгт чухал үүрэгтэй байдаг. Жишээлбэл A данснаас 100 MNT хасаад B данс руу хийхэд “A данснаас 100 MNT хас”, “B данс руу 100 MNT хий” гэсэн хоёр команд ажиллуулах хэрэгтэй. Гэхдээ эдгээр команд хоёулаа амжилттай болох ёстой, аль нэг нь ажиллаад нөгөө нь алдаатай үлдэж болохгүй. Хэрэв аль нэг команд нь алдаатай бол хоёуланг цуцлах хэрэгтэй.

Транзаагц командыг `Begin()` функцээр эхлүүлнэ:

```go
tx, err := db.Begin()
if err != nil {
  log.Fatal(err)
}
// tx.Exec(эхний команд)
// tx.Query(хоёр дахь команд)
// tx.Commit() эсвэл tx.Rollback()
```

`tx` обект дээр өмнө үзсэн `Exec()`, `Query()`, `QueryRow()`, `Prepare()` функцүүдийг дуудаж болно.

Транзагцыг дуусгахын тулд `Commit()` эсвэл `Rollback()` функцийг дуудна.

### NULL утга

Өгөгдлийн сангаас уншсан утга NULL байж болно. Үүнд зориулсан `NullBool`, `NullFloat64`, `NullInt64`, `NullString` төрлүүд бий.

Жишээлбэл дараах асуулгаар буцах `name` талбар NULL байж болно. Тиймээс `NullString` төрлийн обект ашиглаж байна.

```go
var name NullString
err := db.QueryRow("SELECT name FROM names WHERE id = ?", id).Scan(&name)
...
if name.Valid {
  // name.String утгыг ашиглах
} else {
  // NULL утга байна
}
```
